#include <GL/glew.h>
#include <GL/glut.h>

// Automatically link in the GLUT and GLEW libraries if compiling on MSVC++
#ifdef _MSC_VER
#pragma comment(lib, "glew32")
#pragma comment(lib, "freeglut")
#endif

#include <iostream>
#include <vector>
using namespace std;

#include "vertex_geometry_shader.h"


int main(int argc, char **argv)
{
	// This code uses a geometry shader to create 2 triangles for each point "rendered"
	// by the shader. The code only "renders" 1 point, so the total number of triangles
	// generated by the shader is 2. The problem is: how do I obtain the data that define
	// these triangles?

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);
	glutInitWindowSize(10, 10);
	glutInitWindowPosition(0, 0);

	GLint win_id = glutCreateWindow("GS Test");

	if (GLEW_OK != glewInit())
	{
		cout << "GLEW initialization error" << endl;
		return 0;
	}

	int GL_major_version = 0;
	glGetIntegerv(GL_MAJOR_VERSION, &GL_major_version);

	int GL_minor_version = 0;
	glGetIntegerv(GL_MINOR_VERSION, &GL_minor_version);

	if (GL_major_version < 4)
	{
		cout << "GPU does not support OpenGL 4.3 or higher" << endl;
		return 0;
	}
	else if (GL_major_version == 4)
	{
		if (GL_minor_version < 3)
		{
			cout << "GPU does not support OpenGL 4.3 or higher" << endl;
			return 0;
		}
	}

	vertex_geometry_shader g0_mc_shader;

	if (false == g0_mc_shader.init("points.vs.glsl", "points.gs.glsl"))
	{
		cout << "Couldn't load shaders" << endl;
		return 0;
	}

	g0_mc_shader.use_program();

	// Make enough data for 1 point
	vector<float> point_vertex_data;

	point_vertex_data.push_back(0);
	point_vertex_data.push_back(0);
	point_vertex_data.push_back(0);
	point_vertex_data.push_back(0);

	const GLuint components_per_position = 4;
	const GLuint components_per_vertex = components_per_position;

	GLuint point_buffer;

	glGenBuffers(1, &point_buffer);

	const GLuint num_vertices = static_cast<GLuint>(point_vertex_data.size()) / components_per_vertex;

	glBindBuffer(GL_ARRAY_BUFFER, point_buffer);
	glBufferData(GL_ARRAY_BUFFER, point_vertex_data.size() * sizeof(GLfloat), &point_vertex_data[0], GL_DYNAMIC_DRAW);

	glEnableVertexAttribArray(glGetAttribLocation(g0_mc_shader.get_program(), "position"));
	glVertexAttribPointer(glGetAttribLocation(g0_mc_shader.get_program(), "position"),
		components_per_position,
		GL_FLOAT,
		GL_FALSE,
		components_per_vertex * sizeof(GLfloat),
		0);



	unsigned int myTBO;               // Transform Buffer Object (TBO)

	glGenBuffers(1, &myTBO);          // Generate an OpenGL buffer  

	int maxSizeOfFeedback = 100 * sizeof(float);

	glBindBuffer(GL_ARRAY_BUFFER, myTBO);
	glBufferData(GL_ARRAY_BUFFER, maxSizeOfFeedback, (void*)0, GL_STATIC_READ);
	glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, myTBO);




	unsigned int myTBOquery;          // Will hold an OpenGL query object

	glGenQueries(1, &myTBOquery);

	glEnable(GL_RASTERIZER_DISCARD);        // There is no fragment shader; hence no rasterization should be done.

	glBeginQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, myTBOquery);
	glBeginTransformFeedback(GL_TRIANGLES);
	glDrawArrays(GL_POINTS, 0, num_vertices);
	glEndTransformFeedback();               // End of transform feedback
	glEndQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
	unsigned int numEdgesFedBack;
	glGetQueryObjectuiv(myTBOquery, GL_QUERY_RESULT, &numEdgesFedBack);
	glDisable(GL_RASTERIZER_DISCARD);       // Turn rasterization back on

	cout << numEdgesFedBack << endl;






/*
	// how to set up transform feedback?

	GLuint query;

	glGenQueries(1, &query);

	glBeginQuery(GL_PRIMITIVES_GENERATED, query);

	glEnable(GL_RASTERIZER_DISCARD);

//	glBeginTransformFeedback(GL_TRIANGLES);
		glDrawArrays(GL_POINTS, 0, num_vertices);
//	glEndTransformFeedback();

	glDisable(GL_RASTERIZER_DISCARD);

	glEndQuery(GL_PRIMITIVES_GENERATED);

	GLuint primitives;
	glGetQueryObjectuiv(query, GL_QUERY_RESULT, &primitives);

	// Print number of triangles generated by geometry shader -- it should be 2
	cout << primitives << endl;

	// How to now read back the triangle vertex data to a CPU buffer?
	// e.g. How do I get the data 1,2,3 ... 4,5,6... 7,8,9 ... etc., from geometry shader?

	*/

//	glDeleteQueries(1, &query);
///	glDeleteBuffers(1, &point_buffer);
//	glutDestroyWindow(win_id);

	return 1;
}